# zijie面试题

# 有 K名字节君，每天下午都要推着推车给字节的同学送下午茶，字节的同学分布在不同的工区,字节的工区分布和字节君的位置分布如下。
# K名字节君 | 工区1 | 工区2 | 工区3 | 工区N
# 在上图中，每个方框内的单位长度为1。已知字节君的推车可以装无限份下午茶，所以不需要字节君回到初始地点补充下午茶。
# 每个字节君只有两个动作。
# 1.把推车向前移动一个单位。
# 2.把一份下午茶投放到当前工区。

# 现在告诉你字节君的数量以及每个工区需要的下午茶个数请问，所有的字节君最少花费多长时间才能送完所有的下午茶?
# 格式:
# 输入:
# -第一行是字节君的数量K 和工区的数量 N
# - 第二行 N 个数字是每个工区需要的下午茶数量 Ti
# 输出:
# -输出一个数字代表所有字节均最少花费多长时间才能送完所有的下午茶
# 示例 1:
# 输入:
# 3 3
# 7  1 1
# 输出:5
# 解释:
# 字节君1:右移->放置->放置->放置->放置
# 字节君2:右移->放置->放置->放置
# 字节君3:右移->右移->放置->右移->放置


# 思路：要找到一个判断依据：每个字节君 在每个时间点该执行哪个动作

from typing import List
import heapq

def get_min_time(K: int, N: int, T: List[int]) -> int:
    # 将工区需求转化为小根堆，每个元素为一个tuple，tuple的第一个元素表示到工区的时间，即工区编号加1
    # 第二个元素表示工区的下午茶需求
    q = [((i + 1), T[i]) for i in range(N)]
    heapq.heapify(q)

    time = 0
    while q:
        working = []  # 正在工作的字节君
        # 先找出K个字节君需要为哪些工区送茶
        for _ in range(K):
            if q:
                working.append(heapq.heappop(q))
        # 将移动和送茶看作是在同一时间完成的，所以每个字节君会先移动后送茶
        # 同时更新他们所在的工区的下午茶需求
        for i in range(len(working)):
            tea_need = working[i][1] - 1  # 送完一份茶后的剩余需求
            if tea_need > 0:  # 如果还有剩余需求，该工区还需要继续投放
                working[i] = (working[i][0], tea_need)
        # 更新现在的时间
        time += 1
        # 把还需要继续投放的工区放回堆中
        for w in working:
            if w[1] > 0:
                heapq.heappush(q, w)

    return time

# 测试用例
print(get_min_time(3, 3, [7, 1, 1]))  # 输出 : 5





